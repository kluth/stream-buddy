# Stream Buddy GitHub Issues Plan (Major Versions 1-15)

This document contains the `gh issue create` commands for a long-term development roadmap for Stream Buddy, broken down into 15 major versions. Each major version focuses on a set of related features and enhancements, aiming for a "perfectism" OBS alternative with best practices and WASM opportunities.

---

## Major Version 1: Core System Hardening & Advanced Overlay Features

### **Issue 1.1: Feature: Persistent Storage for User and Overlay Configurations**

```bash
gh issue create --title "Feature: Implement Persistent Database Storage for User and Overlay Configurations" --body "## Description\nCurrently, user OAuth tokens (Twitch, YouTube) and created overlay configurations are stored in-memory, leading to data loss upon application restart. This issue addresses the critical need to implement a robust and secure persistent storage solution. This is foundational for any production-ready application.\n\n## Acceptance Criteria\n- User OAuth tokens (access, refresh, expiry, scopes) for Twitch and YouTube are securely stored in a relational database (e.g., PostgreSQL).\n- Overlay configurations (the `OverlayElement[]` JSON array) are persistently stored in the same database, linked to the `internalUserId`.\n- `TwitchAuthService`, `YoutubeAuthService`, and `OverlayRenderService` are updated to use database interactions (read, write, update) instead of the in-memory `tokenStore` and `overlayStore`.\n- Clear schema definitions are established for `UserTokens` and `UserOverlays`.\n- Error handling for database operations is robust.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - **ORM Choice:** Integrate a modern ORM like TypeORM or Prisma for database interactions. (Adhere to NestJS best practices for database integration).\n  - **Database:** Start with SQLite for local development ease, and ensure compatibility with PostgreSQL for production.\n  - **Entities/Schemas:** Define `UserEntity` (to hold `internalUserId`), `UserTokenEntity` (linked to `UserEntity`, storing platform-specific tokens), and `OverlayConfigEntity` (linked to `UserEntity`, storing the `OverlayElement[]` as JSONB or equivalent).\n  - **Security:** Implement encryption for sensitive data (e.g., refresh tokens) at rest within the database.\n\n## Best Practices\n- Utilize database migrations for schema evolution.\n- Follow the repository pattern/service layers for clean database access.\n- Implement robust logging for database interactions."
```

### **Issue 1.2: Enhancement: Expose Granular FFmpeg Encoding Parameters per Platform**

```bash
gh issue create --title "Enhancement: Expose Granular FFmpeg Encoding Parameters per Platform" --body "## Description\nThe current `SimulcastService` uses a basic `ffmpeg -c copy` approach for remuxing streams from MediaMTX to target platforms. To optimize stream quality, stability, and compliance with platform-specific requirements (e.g., Twitch's recommended bitrates, YouTube's resolutions), we need to expose more granular `ffmpeg` encoding parameters.\n\n## Acceptance Criteria\n- `StreamDestination` interface (or a new DTO) is extended to include optional encoding parameters: `videoBitrate (kbps)`, `audioBitrate (kbps)`, `resolution (e.g., \"1920x1080\")`, `frameRate (fps)`, `keyframeInterval (seconds)`, `codecProfile (e.g., \"main\")`, `encodingPreset (e.g., \"veryfast\")`.\n- `SimulcastService.buildFfmpegCommand` is updated to dynamically construct a sophisticated `ffmpeg` command string, applying these parameters for each specified platform output.\n- Ensure default optimal parameters are applied if none are specified (e.g., H.264/AAC, CBR, common resolutions/bitrates).\n- Frontend UI in `SimulcastSetupComponent` is updated to allow users to configure these parameters per platform.\n\n## Technical Details\n- **Backend (`apps/api/src/app/simulcast/`):**\n  - Update `StreamDestination` in `interfaces.ts`.\n  - Modify `buildFfmpegCommand` in `simulcast.service.ts` to parse and apply new `ffmpeg` options.\n  - Consider validating parameter combinations to prevent invalid `ffmpeg` commands.\n- **Frontend (`apps/stream-buddy/src/app/features/simulcast-setup/`):**\n  - Add form fields (dropdowns, number inputs) to `simulcast-setup.html` and logic to `simulcast-setup.ts` to manage these new encoding parameters.\n\n## Best Practices\n- Extensive input validation for `ffmpeg` parameters (e.g., numerical ranges, valid strings).\n- Clear feedback to the user regarding valid parameter combinations.\n- Consider integrating `ffmpeg` wrapper libraries for safer command construction if manual string concatenation becomes overly complex."
```

### **Issue 1.3: Feature: Real-time Overlay Element Manipulation in Editor (Drag, Resize, Rotate)**

```bash
gh issue create --title "Feature: Implement Direct Manipulation (Drag, Resize, Rotate) for Overlay Elements in Editor" --body "## Description\nThe current `OverlayEditorComponent` relies on numerical inputs for positioning and sizing. To provide an intuitive and efficient user experience, direct manipulation of overlay elements (drag-to-move, resize handles, rotation controls) on the canvas preview is essential.\n\n## Acceptance Criteria\n- Users can click and drag any `overlay-element-preview` div to change its `x` and `y` coordinates.\n- `overlay-element-preview` divs display resize handles, allowing users to intuitively adjust `width` and `height`.\n- `overlay-element-preview` divs display a rotation handle, enabling users to change `rotation`.\n- All changes made via direct manipulation are immediately reflected in the properties panel and update the `selectedElement`'s properties.\n- Manipulation is smooth and responsive.\n\n## Technical Details\n- **Frontend (`apps/stream-buddy/src/app/features/overlay-editor/`):**\n  - Utilize an Angular library or implement custom logic for drag, resize, and rotate.\n  - **Recommendation:** Leverage Angular CDK Drag and Drop (`@angular/cdk/drag-drop`) for dragging. For resizing and rotating, consider dedicated libraries like `angular-resizable-element` or implement custom pointer event handlers.\n  - Ensure CSS styles support visual feedback (e.g., active borders, handles).\n  - Update `updateSelectedElementProperty` method or create new methods to handle continuous updates during manipulation.\n\n## Best Practices\n- Debouncing or throttling updates during continuous manipulation to prevent excessive change detection.\n- Clear visual feedback (e.g., active borders, resize handles) during interaction.\n- Touch-friendly interaction for potential mobile editing (future consideration)."
```

### **Issue 1.4: Feature: Dynamic Stream Metadata Update API and UI**

```bash
gh issue create --title "Feature: Implement Real-time Stream Metadata Update API and UI" --body "## Description\nStreamers frequently need to update their stream's title, game/category, or description during a live broadcast. This feature will enable users to perform these updates directly within the Stream Buddy UI, which then propagates the changes to connected streaming platforms via their respective APIs.\n\n## Acceptance Criteria\n- The backend `SimulcastController` (specifically the `POST /api/simulcast/update-metadata` endpoint) correctly processes requests to update metadata.\n- The frontend UI (e.g., in a new dedicated \"Stream Info\" section or within `SimulcastSetupComponent` / `LiveDashboardComponent`) provides intuitive input fields for stream title, game/category, and description.\n- Changes made in the UI are successfully pushed to the backend API.\n- Backend `TwitchAuthService` (`updateChannelInfo`) and `YoutubeAuthService` (`updateLiveBroadcast`) successfully invoke platform-specific APIs to apply metadata changes.\n- The UI provides clear feedback (loading states, success/error messages) for metadata update operations.\n- For Twitch, a mechanism to search/select Twitch game IDs is integrated. For YouTube, a mechanism to select a YouTube category ID is integrated.\n\n## Technical Details\n- **Frontend (`apps/stream-buddy/`):**\n  - Design and implement a form for metadata editing.\n  - Implement Angular services to interact with the backend `/api/simulcast/update-metadata` endpoint.\n- **Backend (`apps/api/src/app/simulcast/`, `apps/api/src/app/twitch-auth/`, `apps/api/src/app/youtube-auth/`):**\n  - Ensure `SimulcastService.updateStreamMetadata` is robustly implemented.\n  - `TwitchAuthService.updateChannelInfo`: Needs to convert game name to `gameId` using Twitch API (e.g., `apiClient.games.getGameByName()`).\n  - `YoutubeAuthService.updateLiveBroadcast`: Needs to correctly map a user-friendly category to `categoryId`.\n\n## Best Practices\n- Thorough input validation on both frontend and backend.\n- Optimistic UI updates where appropriate for perceived responsiveness."
```

### **Issue 1.5: Feature: Advanced Audio Processing for Inputs (WASM Opportunity)**

```bash
gh issue create --title "Feature: Implement Advanced Audio Processing for Input Sources (Noise Suppression, Echo Cancellation)" --body "## Description\nWhile `MediaCaptureService` can request browser-native audio constraints (echo cancellation, noise suppression), these are often limited. Implementing more advanced, custom audio processing algorithms (e.g., Krisp-like noise suppression, enhanced echo cancellation) directly within Stream Buddy will significantly improve audio quality for streamers. This is an ideal candidate for WebAssembly.\n\n## Acceptance Criteria\n- Integrate a WebAssembly (WASM) module (or a JavaScript library leveraging WASM) for real-time audio processing (e.g., a more advanced noise suppression algorithm).\n- `MediaCaptureService` or `AudioMixerService` is extended to apply these custom audio processing effects to microphone input streams.\n- UI controls are provided in Stream Buddy (e.g., in the `LiveDashboardComponent` or a dedicated Audio Settings component) to enable/disable and configure these advanced audio effects.\n- Processing is performed efficiently without introducing significant audio latency or browser stutter.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - Research and select a suitable open-source audio processing library (e.g., based on WebRTC's audio processing, RNNoise, or similar) that can be compiled to WASM.\n  - Compile the chosen library to WASM.\n  - Integrate the WASM module into `AudioMixerService` or a new `AudioProcessorService`.\n  - Use `AudioWorkletProcessor` (Web Audio API) to run the WASM-based audio processing on a dedicated thread, minimizing impact on the main UI thread.\n  - Connect the output of `MediaCaptureService`'s microphone `MediaStreamTrack` to the `AudioWorkletProcessor`.\n\n## Best Practices\n- Efficient WASM module loading and instantiation.\n- Careful management of `AudioWorkletProcessor` lifecycle.\n- Benchmarking to ensure performance gains outweigh overhead.\n- Providing clear user controls and feedback on audio processing status."
```

---

## Major Version 2: Advanced Scene Management & Multi-Platform Publishing

### **Issue 2.1: Feature: Configurable Scene Transitions and Effects**

```bash
gh issue create --title "Feature: Implement Configurable Scene Transitions and Effects" --body "## Description\nProfessional streams utilize smooth transitions between different scenes (e.g., BRB screen, gameplay, webcam-only). This feature will introduce a system for defining and applying various transition effects (e.g., fade, cut, wipe, custom stinger transitions) when switching between composed scenes. This will significantly enhance the production quality of streams from Stream Buddy.\n\n## Acceptance Criteria\n- `SceneCompositorService` (or a new `TransitionService`) is enhanced to apply configurable transitions when `setComposition` is called.\n- A library for common transitions (e.g., WebGL-based effects or CSS animations for canvas) is integrated.\n- Frontend UI allows users to select a transition type and configure its properties (duration, direction) for each scene switch.\n- Transitions are smooth and performant, not causing drops in frame rate.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - Modify `SceneCompositorService.setComposition` to handle a \"previous\" and \"next\" scene during transition.\n  - Research and integrate a suitable WebGL/canvas-based transition library.\n  - Implement transition logic directly on the canvas (e.g., drawing portions of both scenes during the transition).\n  - UI elements for selecting and configuring transitions.\n\n## Best Practices\n- Focus on GPU-accelerated transitions to maintain performance.\n- Provide a good selection of common transition types.\n- Allow custom transition creation (future enhancement)."
```

### **Issue 2.2: Feature: Dynamic Scene Elements & Interactive Filters (WASM Opportunity for Filters)**

```bash
gh issue create --title "Feature: Implement Dynamic Scene Elements & Interactive Filters" --body "## Description\nBeyond static overlays, streams can benefit from dynamic visual elements (e.g., visualizers, interactive mini-games) and real-time video filters (e.g., blur, green screen). This feature aims to add support for these elements and introduce real-time video processing capabilities.\n\n## Acceptance Criteria\n- `SceneCompositorService` can render dynamic elements that react to audio input (visualizers) or stream events (e.g., confetti for a raid).\n- Implement real-time video filters (e.g., blur, color correction, basic green screen chroma keying) that can be applied to `MediaStream` sources.\n- UI controls in `SceneEditor` or `LiveDashboard` to apply and configure these filters.\n- Filters are performant and don't introduce significant latency.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - **Dynamic Elements:** Use Web Audio API for audio analysis for visualizers. Implement logic for event-triggered animations directly on the canvas.\n  - **Video Filters:**\n    - **WASM Opportunity:** For complex video filters (e.g., efficient chroma keying, advanced blur algorithms), WebAssembly can provide significant performance benefits over pure JavaScript. Research existing image processing libraries (e.g., OpenCV.js) or custom WASM implementations for these effects.\n    - Integrate filter application within `SceneCompositorService`'s `renderFrame` loop, applying filter effects to `MediaStream` sources before drawing them to the canvas.\n\n## Best Practices\n- Prioritize GPU-accelerated rendering for all visual effects.\n- Provide a library of common, performant filters.\n- Modular filter architecture to allow for easy extension."
```

### **Issue 2.3: Feature: Picture-in-Picture (PiP) & Multi-Source Layouts**

```bash
gh issue create --title "Feature: Implement Flexible Picture-in-Picture & Multi-Source Layouts" --body "## Description\nStreamers often use complex layouts, combining multiple video sources (e.g., webcam, gameplay, screen share) in various arrangements. This feature will provide robust tools for creating flexible PiP and multi-source layouts within a scene, going beyond simple scaling and positioning.\n\n## Acceptance Criteria\n- `SceneCompositorService` supports defining complex layout regions for `MediaStream` sources (e.g., PiP corner inserts, side-by-side, grid layouts).\n- Frontend UI provides templates and tools for creating and saving custom multi-source layouts.\n- Users can assign different `MediaStream` inputs (camera, screen, specific applications) to these layout regions.\n- Layouts are responsive and easily adjustable.\n\n## Technical Details\n- **Frontend (`libs/core/models/`, `libs/core/services/`, `apps/stream-buddy/`):**\n  - Update `SceneComposition` model to define layout \"slots\" or regions.\n  - `SceneCompositorService` rendering logic is updated to draw sources within these defined regions.\n  - `SceneEditor` component provides a visual builder for creating these layouts (drag-and-drop regions, snapping).\n\n## Best Practices\n- Use CSS Grid or Flexbox principles for layout tools in the editor UI.\n- Ensure performant rendering even with many sources on canvas."
```

### **Issue 2.4: Enhancement: Stream Event Webhook Integration (Platform APIs)**

```bash
gh issue create --title "Enhancement: Integrate Real-time Stream Event Webhooks from Twitch & YouTube" --body "## Description\nThe current implementation uses a simulated event endpoint for overlays. To enable truly dynamic and real-time reactions on stream (e.g., follower alerts, chat messages), Stream Buddy needs to integrate with actual platform webhooks.\n\n## Acceptance Criteria\n- Implement robust webhook endpoints in `apps/api` for Twitch EventSub and YouTube PubSubHubbub.\n- Properly verify webhook signatures to ensure authenticity.\n- Backend automatically subscribes to relevant events (e.g., new follower, new subscriber, chat messages) for authenticated users.\n- Upon receiving a webhook event, the backend `StreamEventsGateway` emits the corresponding WebSocket event to connected frontend clients (e.g., `SceneCompositorService`).\n- Clear error handling and logging for webhook processing.\n\n## Technical Details\n- **Backend (`apps/api/webhooks/`, `apps/api/src/app/stream-events/`):**\n  - Create new `WebhooksModule` and `WebhooksController`.\n  - Implement Twitch EventSub callback handler (requires a publicly accessible URL, e.g., via ngrok for local testing).\n  - Implement YouTube PubSubHubbub callback handler.\n  - Develop logic to map webhook payloads to internal `StreamEvent` types and emit via `StreamEventsGateway`.\n  - Persist webhook subscription details (e.g., `subscriptionId`).\n\n## Best Practices\n- Strict webhook payload validation and signature verification.\n- Asynchronous processing of webhook events to prevent blocking.\n- Graceful handling of subscription management (renewal, error recovery)."
```

### **Issue 2.5: Feature: Advanced Audio Mixer & Routing**

```bash
gh issue create --title "Feature: Implement Advanced Audio Mixer with Per-Source Control & Routing" --body "## Description\nThe `AudioMixerService` currently exists. This feature will enhance it to provide granular control over each audio input source (microphone, desktop audio, game audio, specific application audio). This includes per-source volume, mute/unmute, and routing to different output channels or even virtual audio devices.\n\n## Acceptance Criteria\n- UI in Stream Buddy (e.g., `LiveDashboard`) displays individual audio levels for each input source.\n- Users can adjust volume, mute/unmute, and apply basic filters (e.g., gain, compressor) to each audio source independently.\n- Implement an audio routing matrix to send audio from specific sources to different virtual outputs (future enhancement: inter-application audio routing).\n- Audio processing is performed with minimal latency.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - `AudioMixerService` is extended to manage multiple `AudioContext` sources.\n  - Use Web Audio API `GainNode`, `AnalyserNode`, `DynamicsCompressorNode`, etc., for per-source control.\n  - UI elements for volume sliders, mute buttons, and audio visualizations.\n  - **WASM Opportunity:** For very specific, low-latency DSP (Digital Signal Processing) effects (e.g., complex EQs, noise gates), WASM can be integrated into `AudioWorkletProcessors`.\n\n## Best Practices\n- Efficient Web Audio API graph management.\n- Clear visual feedback for audio levels (VU meters).\n- Prioritize low latency for audio processing."
```

---

## Major Version 3: Multi-User & Collaborative Streaming

### **Issue 3.1: Feature: User Authentication and Authorization System**

```bash
gh issue create --title "Feature: Implement Robust User Authentication and Authorization System" --body "## Description\nTo support multi-user and collaborative features, Stream Buddy requires a full-fledged user authentication and authorization system. This will secure API endpoints and manage user-specific data and permissions.\n\n## Acceptance Criteria\n- Users can register and log in to Stream Buddy.\n- User sessions are managed securely (e.g., JWTs, session cookies).\n- API endpoints are protected with appropriate authentication and authorization middleware.\n- User data (e.g., associated platform accounts, saved overlays) is correctly linked to authenticated users.\n- Frontend UI provides login/registration pages and user session management.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Implement NestJS authentication modules (e.g., using `@nestjs/passport` with JWT strategy).\n  - Integrate with database (from Issue 1.1) to store user credentials (hashed passwords).\n  - Implement authorization guards and decorators.\n- **Frontend (`apps/stream-buddy`):**\n  - Implement login, registration, and logout forms.\n  - Store and manage JWTs/session tokens securely (e.g., HttpOnly cookies).\n\n## Best Practices\n- Use strong password hashing algorithms (e.g., bcrypt).\n- Implement secure token management (e.g., refresh tokens).\n- Adhere to OAuth 2.0 best practices for third-party integrations."
```

### **Issue 3.2: Feature: Remote Guest / Co-Stream Integration (WebRTC SFU)**

```bash
gh issue create --title "Feature: Implement Remote Guest / Co-Stream Integration via WebRTC SFU" --body "## Description\nEnable streamers to bring remote guests into their broadcast or facilitate co-streaming with other Stream Buddy users. This will require integrating a WebRTC Selective Forwarding Unit (SFU) server for efficient multi-party video conferencing.\n\n## Acceptance Criteria\n- Stream Buddy users can generate invite links for guests.\n- Guests can join a private WebRTC session via the invite link.\n- The host's `SceneCompositorService` receives guest audio/video streams.\n- Host can add guest streams as sources in their scene composition.\n- Guest streams are integrated into the final output with minimal latency.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - **SFU Integration:** Deploy and integrate with an open-source WebRTC SFU (e.g., Mediasoup, Janus, Pion WebRTC SFU in Go). This could be another Docker container.\n  - **Signaling Server:** Implement a signaling server (e.g., via WebSockets) to manage SDP exchange and ICE candidates for multi-party WebRTC.\n  - **Authentication:** Secure guest invite links and SFU access.\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - Update `WebRTCGatewayService` or create a new service to manage SFU client connections.\n  - Update `SceneCompositorService` to handle multiple incoming `MediaStream`s from the SFU.\n  - UI for managing guests (add/remove, mute/unmute, add to scene).\n\n## Best Practices\n- Prioritize low-latency and high-quality for guest streams.\n- Implement robust error handling for network interruptions.\n- Secure SFU signaling and media transport."
```

### **Issue 3.3: Feature: Role-Based Access Control (RBAC) for Collaborative Streams**

```bash
gh issue create --title "Feature: Implement Role-Based Access Control (RBAC) for Collaborative Streams" --body "## Description\nFor collaborative streaming or when a streamer has moderators, an RBAC system is needed to define and enforce permissions (e.g., who can change scene, who can ban chat, who can manage guests).\n\n## Acceptance Criteria\n- Users can define custom roles (e.g., Editor, Moderator, Guest).\n- Permissions are assignable to roles (e.g., `scene:edit`, `chat:moderate`, `guest:manage`).\n- Users can be assigned roles for a specific stream/channel.\n- Backend API enforces these roles for all privileged operations.\n- Frontend UI reflects user permissions (e.g., disabling buttons for unauthorized actions).\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Extend user schema with roles and permissions.\n  - Implement RBAC logic in NestJS guards and interceptors.\n  - Store roles and permissions in the database (Issue 1.1).\n- **Frontend (`apps/stream-buddy`):**\n  - Implement UI for role assignment and permission management.\n  - Dynamically enable/disable UI elements based on user's current permissions.\n\n## Best Practices\n- Granular permission definitions.\n- Centralized permission checking logic.\n- Clear visual indicators of permissions in the UI."
```

### **Issue 3.4: Feature: Live Chat Moderation Tools**

```bash
gh issue create --title "Feature: Implement Integrated Live Chat Moderation Tools" --body "## Description\nEffective moderation is key for a healthy streaming community. This feature will provide integrated tools within Stream Buddy to monitor and moderate live chat from connected platforms (Twitch Chat, YouTube Live Chat).\n\n## Acceptance Criteria\n- `StreamEventsGateway` (backend) receives and consolidates chat messages from Twitch and YouTube webhooks.\n- UI displays a consolidated chat feed (e.g., in a dedicated moderation panel).\n- Moderators can perform common actions: timeout users, ban users, delete messages.\n- Chat actions are pushed to the respective platform APIs.\n- Filters for spam, hate speech (future enhancement: AI moderation).\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Enhance webhook handlers (Issue 2.4) to parse chat messages.\n  - Create endpoints for moderation actions.\n  - Implement `TwitchAuthService` and `YoutubeAuthService` methods for moderation API calls.\n- **Frontend (`apps/stream-buddy`):**\n  - Dedicated chat moderation UI component.\n  - Real-time display of chat messages and moderation actions.\n\n## Best Practices\n- Respect platform-specific moderation rules.\n- Provide clear logs of moderation actions."
```

### **Issue 3.5: Enhancement: Stream Health Dashboard & Alerting**

```bash
gh issue create --title "Enhancement: Create Comprehensive Stream Health Dashboard and Alerting System" --body "## Description\nExpand on the basic stream stats (Issue 1.5) to provide a comprehensive, actionable dashboard for monitoring stream health across all platforms, including alerting for critical issues.\n\n## Acceptance Criteria\n- Dashboard displays aggregated stream metrics: overall bitrate, CPU/GPU usage (browser-side), dropped frames, platform-specific health indicators.\n- Configurable alerts for critical events (e.g., stream offline, bitrate drops below threshold, excessive dropped frames, platform API errors).\n- Alerts are visible in the UI and can trigger notifications (e.g., desktop notifications).\n- Historical data logging and visualization for post-stream analysis.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - Expand `StreamMonitoringService` to aggregate more data points.\n  - Implement charting/graphing library for historical data visualization.\n  - Desktop notification API integration.\n- **Backend (`apps/api`):**\n  - Enhance MediaMTX metric fetching (Issue 1.5).\n  - Implement background services for threshold monitoring and alert generation.\n  - Store historical metrics in the database (Issue 1.1).\n\n## Best Practices\n- Clear, actionable alerts.\n- Minimal performance impact from monitoring.\n- User-configurable thresholds."
```

---

## Major Version 4: Advanced Media Sources & Integrations

### **Issue 4.1: Feature: Virtual Webcam & Virtual Microphone Output**

```bash
gh issue create --title "Feature: Implement Virtual Webcam and Virtual Microphone Output" --body "## Description\nTo enhance compatibility with other applications and provide a more versatile output, Stream Buddy should be able to present its final composed audio/video stream as a virtual webcam and virtual microphone device to the operating system.\n\n## Acceptance Criteria\n- Stream Buddy's combined output stream (video with overlays, mixed audio) is available as a selectable webcam device in other applications (e.g., Zoom, Discord).\n- Stream Buddy's mixed audio is available as a selectable microphone device in other applications.\n- Output is low-latency and high-quality.\n- (Future enhancement) Cross-platform compatibility (Windows, macOS, Linux).\n\n## Technical Details\n- **System-level Integration (OS specific):**\n  - This requires native code integration using OS-specific APIs for virtual devices (e.g., OBS Virtualcam, VB-Cable).\n  - **WASM Opportunity:** While WASM can't directly create virtual devices, it could be used in a separate native component or electron app which bridges the browser stream to the virtual device.\n  - **Recommendation:** Implement as a native Electron/desktop application component or a separate utility.\n- **Frontend (`libs/core/services/`):**\n  - `SceneCompositorService` output stream is piped to the native virtual device component.\n\n## Best Practices\n- Maintain low resource usage for the virtual device driver.\n- Clear user instructions for setup on different OS."
```

### **Issue 4.2: Feature: Browser Source Input Integration**

```bash
gh issue create --title "Feature: Integrate External Browser Source Input" --body "## Description\nAllow users to add any web page or web application as a source within their Stream Buddy scenes, similar to OBS's browser source. This enables dynamic content, widgets, and other web-based elements to be easily incorporated.\n\n## Acceptance Criteria\n- Users can add a URL as a new source type in `SceneEditor`.\n- The content of the specified URL is rendered and integrated into the `SceneCompositorService`'s output.\n- Input browser sources support CSS customization and JavaScript interaction.\n- Browser source input is performant and handles common web content (e.g., alerts, chat overlays).\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - **Rendering:** This is challenging in a browser. Options include:\n    - Using an `<iframe sandbox='allow-scripts'>` and drawing its content to canvas (limited functionality, CORS issues).\n    - **WASM Opportunity (Advanced):** Use a WASM-compiled headless browser (like `Chromium` or `WebKit` via `Playwright`/`Puppeteer` bindings if they become feasible client-side) in a dedicated Web Worker to render the HTML and then push frames to the canvas.\n    - **Recommendation (MVP):** Use an `<iframe` and accept its limitations, or implement via a native Electron component that can capture rendered web views. The \"browser source\" should actually be a browser *view* captured and integrated.\n  - UI for adding URL, dimensions, and custom CSS/JS.\n- **Backend (`apps/api/`):**\n  - Potentially a backend proxy for certain URLs to bypass CORS for client-side rendering."
```

### **Issue 4.3: Feature: NDI / SRT Output Support**

```bash
gh issue create --title "Feature: Implement NDI / SRT Output Support" --body "## Description\nProvide professional-grade local network streaming capabilities by adding support for NDI (Network Device Interface) and/or SRT (Secure Reliable Transport) outputs. This allows Stream Buddy's output to be consumed by other production software and hardware.\n\n## Acceptance Criteria\n- Stream Buddy's composed output stream can be sent as an NDI source on the local network.\n- Stream Buddy's composed output stream can be sent as an SRT stream to a specified destination.\n- Both NDI and SRT outputs are low-latency and high-quality.\n- Frontend UI allows enabling/disabling and configuring NDI/SRT outputs.\n\n## Technical Details\n- **Native Integration (OS specific):**\n  - Both NDI and SRT typically require native libraries or specialized `ffmpeg` builds.\n  - **Recommendation:** Implement as a native Electron/desktop application component that interfaces with the NDI SDK or a WASM-compiled SRT library (if available).\n- **MediaMTX:** SRT support can be integrated directly into MediaMTX if not already present, or use `ffmpeg` output pipes for SRT.\n- **WASM Opportunity:** If efficient SRT client libraries can be compiled to WASM and run in Web Workers, this could be a browser-only solution, but usually requires more control than browsers offer natively for network protocols.\n\n## Best Practices\n- Ensure proper network configuration and firewall rules are communicated to the user.\n- Prioritize low-latency and reliability for professional use cases."
```

### **Issue 4.4: Feature: Local Recording and Replay Buffer**

```bash
gh issue create --title "Feature: Implement Local Recording and Replay Buffer Functionality" --body "## Description\nStreamers need reliable local recording for backup, editing, and highlight generation. A replay buffer allows saving recent gameplay moments instantly. This feature will add these capabilities to Stream Buddy.\n\n## Acceptance Criteria\n- Users can start/stop local recording of the final composed stream output.\n- Recordings are saved to a user-configurable location in a standard format (e.g., MP4).\n- Users can enable a replay buffer that continuously records the last X minutes/seconds of the stream.\n- A hotkey or UI button allows saving the content of the replay buffer to a file.\n- Recordings and replay saves are performant and don't impact live stream quality.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - **Recording:** Use `MediaRecorder API` on the `SceneCompositorService`'s output stream (`canvas.captureStream()`).\n  - **Replay Buffer:** Implement a circular buffer using `MediaRecorder` or a custom `MediaSource` + `MediaSourceBuffer` approach.\n  - UI for recording controls (start/stop, pause, save replay).\n  - Access to local file system for saving (requires browser permission, or Electron/native app component).\n- **WASM Opportunity:** For advanced recording features like multiple audio tracks or more control over video codec settings than `MediaRecorder` offers, a WASM-compiled `ffmpeg` or `webm.js` (for WebM) could be used for more granular control.\n\n## Best Practices\n- Handle large file sizes efficiently.\n- Provide clear feedback on recording status and file size.\n- Offer configurable recording quality settings."
```

### **Issue 4.5: Feature: Background Noise Reduction for Desktop Audio**

```bash
gh issue create --title "Feature: Implement Background Noise Reduction for Desktop Audio" --body "## Description\nExtend audio processing capabilities to include background noise reduction specifically for desktop audio sources (e.g., game audio, other applications). This helps clean up the overall stream audio by removing unwanted ambient noise from game sound or application chatter.\n\n## Acceptance Criteria:\n- Users can add desktop audio as a source.\n- A configurable noise reduction filter can be applied to individual desktop audio sources.\n- UI controls to enable/disable and adjust the intensity of noise reduction.\n- Processing is real-time and doesn't introduce noticeable latency or audio artifacts.\n\n## Technical Details:\n- **Frontend (`libs/core/services/`):**\n  - `MediaCaptureService` needs to implement `getDesktopAudio` (if not already present or feasible for specific applications).\n  - `AudioMixerService` is enhanced to apply noise reduction to specific tracks.\n  - **WASM Opportunity:** Implement noise reduction algorithms (e.g., `RNNoise` or similar) compiled to WASM and integrate them via `AudioWorkletProcessors` for optimal performance in the browser.\n\n## Best Practices:\n- Provide user-friendly controls for filter intensity.\n- Ensure compatibility with various desktop audio capture methods."
```

---

## Major Version 5: Cloud Integration & Advanced Monetization

### **Issue 5.1: Feature: Cloud Stream Management (Scheduled Streams, VOD Upload)**

```bash
gh issue create --title "Feature: Implement Cloud Stream Management (Scheduled Streams, VOD Upload)" --body "## Description\nIntegrate Stream Buddy with platform-specific cloud APIs to allow for advanced stream management, including scheduling streams directly from the application and automated VOD (Video On Demand) uploads after a broadcast.\n\n## Acceptance Criteria:\n- Users can schedule upcoming streams for Twitch and YouTube directly within Stream Buddy, setting title, game, and time.\n- Stream Buddy displays a calendar/list of scheduled streams.\n- After a local recording (Issue 4.4) or a live broadcast, users can trigger an automated upload of the VOD to Twitch/YouTube.\n- VOD uploads include metadata and can be set to public/private.\n\n## Technical Details:\n- **Backend (`apps/api`):**\n  - Extend `TwitchAuthService` and `YoutubeAuthService` to call platform APIs for scheduling broadcasts and uploading videos.\n  - Implement endpoints for scheduling and VOD upload requests.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for scheduling streams (date/time pickers, metadata forms).\n  - UI for VOD management (selecting local files, uploading progress, metadata).\n- **Best Practices:**\n  - Handle large file uploads asynchronously and provide progress feedback.\n  - Respect platform API rate limits and best practices for scheduling/uploading."
```

### **Issue 5.2: Feature: Integrated Donation & Alert System**

```bash
gh issue create --title "Feature: Implement Integrated Donation and Third-Party Alert System" --body "## Description\nCreate Stream Buddy's own donation system or integrate seamlessly with popular third-party donation platforms (e.g., Streamlabs, Streamelements) to trigger alerts and manage contributions directly.\n\n## Acceptance Criteria:\n- Stream Buddy can receive notifications from major donation platforms (either via webhooks or API polling).\n- These notifications trigger `new-donation-alert` events on the `StreamEventsGateway`.\n- Users can configure alert overlays within Stream Buddy to react to donations.\n- (Future) Implement a basic native donation page/link for Stream Buddy users.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Create `DonationModule` to manage donation platform integrations.\n  - Implement webhooks for receiving donation alerts from Streamlabs/Streamelements.\n  - Map donation events to `StreamEventsGateway` emissions.\n- **Frontend (`apps/stream-buddy`, `libs/core/services/`):**\n  - `OverlayRendererService` and `SceneCompositorService` handle `new-donation-alert` events for overlay rendering (Issue 2.4.2).\n  - UI for configuring donation platform integration (API keys, webhooks).\n\n## Best Practices:\n- Secure handling of sensitive API keys and webhook secrets.\n- Robust error handling for third-party integrations.\n- Clear consent and disclosure for user donations."
```

### **Issue 5.3: Feature: Channel Points & Loyalty System Integration**

```bash
gh issue create --title "Feature: Integrate Twitch Channel Points & Loyalty System" --body "## Description\nLeverage Twitch Channel Points and other platform loyalty systems to create interactive stream experiences, allowing viewers to redeem rewards that trigger actions within Stream Buddy (e.g., on-screen animations, sound effects, scene changes).\n\n## Acceptance Criteria:\n- Stream Buddy receives Twitch Channel Point redemption events via webhooks/API.\n- `StreamEventsGateway` emits `channel-point-redemption` events.\n- Users can map specific Channel Point rewards to actions within Stream Buddy (e.g., play sound, show image overlay, trigger scene transition).\n- Frontend UI for configuring and managing Channel Point rewards and their associated actions.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Extend Twitch webhook integration (Issue 2.4) to listen for Channel Point redemption events.\n  - Implement storage for user-defined Channel Point actions.\n- **Frontend (`apps/stream-buddy`, `libs/core/services/`):**\n  - UI for listing Twitch Channel Point rewards and assigning actions to them.\n  - `SceneCompositorService` (or a new `ActionTriggerService`) handles executing actions based on WebSocket events.\n\n## Best Practices:\n- Design an intuitive mapping interface for rewards to actions.\n- Ensure quick and reliable execution of actions on redemption."
```

### **Issue 5.4: Enhancement: Cloud Storage for Assets**

```bash
gh issue create --title "Enhancement: Cloud Storage Integration for Overlay Assets" --body "## Description\nAllow users to store their overlay assets (images, videos, custom fonts) in cloud storage (e.g., AWS S3, Google Cloud Storage) rather than relying solely on local files. This enables easier backup, multi-device access, and collaborative editing.\n\n## Acceptance Criteria:\n- Users can connect their cloud storage accounts.\n- Frontend UI allows uploading assets directly to configured cloud storage.\n- `ImageOverlayElement` and `VideoOverlayElement` can reference URLs from cloud storage.\n- Backend API handles secure uploads and serves private assets if necessary.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Create `CloudStorageModule` to integrate with AWS S3, Google Cloud Storage APIs.\n  - Implement endpoints for authenticated uploads and retrieval of asset URLs.\n  - Store asset metadata in the database (Issue 1.1).\n- **Frontend (`apps/stream-buddy`):**\n  - UI for managing cloud storage connections.\n  - Asset library browser that integrates with cloud storage.\n\n## Best Practices:\n- Secure handling of cloud storage credentials.\n- Implement proper access control for stored assets.\n- Optimize asset delivery (e.g., CDN integration)."
```

### **Issue 5.5: Feature: Stream Scheduling & Countdown Overlays**

```bash
gh issue create --title "Feature: Implement Advanced Stream Scheduling & Countdown Overlays" --body "## Description\nProvide integrated tools for scheduling streams and automatically displaying customizable countdown timers and 'starting soon' screens within Stream Buddy's scene composition. This enhances the pre-stream experience for viewers.\n\n## Acceptance Criteria:\n- Users can define a stream schedule (date, time, duration, title, scene).\n- An automated 'starting soon' scene is displayed with a countdown timer before the scheduled live time.\n- Countdown timers are customizable in terms of appearance (font, color, background).\n- Stream Buddy can automatically switch to the main scene when the countdown finishes.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Extend scheduling logic (Issue 5.1) to include scene associations.\n  - Implement a timer/scheduler service to trigger scene changes.\n- **Frontend (`apps/stream-buddy`, `libs/core/services/`):**\n  - UI for defining stream schedules.\n  - `SceneCompositorService` draws dynamic countdown timers (TextOverlayElement variant).\n  - `StreamOrchestrationService` integrates with the scheduler to trigger scene transitions.\n\n## Best Practices:\n- Accurate time synchronization for countdowns.\n- Intuitive UI for scheduling and scene mapping."
```

---

## Major Version 6: Platform Enhancements & Cross-Platform Desktop

### **Issue 6.1: Feature: Multi-Platform Chat Integration**

```bash
gh issue create --title "Feature: Implement Unified Multi-Platform Chat Integration" --body "## Description\nProvide a unified chat interface within Stream Buddy that aggregates chat messages from all connected platforms (Twitch, YouTube, custom platforms). This centralizes communication for the streamer.\n\n## Acceptance Criteria:\n- `StreamEventsGateway` (backend) consolidates chat messages from all configured webhook sources.\n- Frontend UI displays a single, real-time chat feed with messages from all platforms, clearly indicating the source.\n- Users can reply to messages (where supported by platform APIs) directly from the unified chat.\n- Customization options for chat appearance (colors, fonts, message display).\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Enhance `StreamEventsGateway` to handle and normalize diverse chat message formats.\n  - Implement logic to send replies to specific platform chat APIs.\n- **Frontend (`apps/stream-buddy`):**\n  - Dedicated unified chat UI component.\n  - `OverlayRendererService` provides consolidated chat data.\n\n## Best Practices\n- Clear platform indicators for each message.\n- Robust error handling for chat API interactions.\n- Compliance with platform-specific chat rules and API limits."
```

### **Issue 6.2: Feature: Cross-Platform Desktop Application (Electron)**

```bash
gh issue create --title "Feature: Develop Cross-Platform Desktop Application using Electron" --body "## Description\nWhile Stream Buddy currently runs in a browser, a dedicated desktop application offers advantages like better performance, deeper OS integration (virtual devices, global hotkeys, application capture), and an enhanced user experience.\n\n## Acceptance Criteria\n- Stream Buddy is packaged as a standalone desktop application for Windows, macOS, and Linux.\n- The desktop app leverages system-level APIs for features like virtual webcam/mic (Issue 4.1), advanced desktop/application capture, and global hotkeys.\n- The application's core functionality (frontend and backend) remains largely the same, leveraging the existing web technologies.\n\n## Technical Details\n- **Framework:** Use Electron (or similar framework like Tauri if more Rust integration is desired).\n- **Architecture:** The existing Angular frontend can run as the renderer process. The Node.js backend can be either bundled with Electron or run as a separate local process.\n- **Native Modules:** Develop native Node.js addons or bridge modules to interface with OS-specific APIs for features like:\n  - Virtual camera/microphone devices.\n  - Low-latency application/game window capture (e.g., DirectX/OpenGL hooks for Windows).\n  - Global hotkey registration.\n\n## Best Practices\n- Optimize Electron app for low resource usage (memory, CPU).\n- Implement auto-updates for the desktop application.\n- Ensure consistent user experience across different operating systems."
```

### **Issue 6.3: Feature: Global Hotkey Management**

```bash
gh issue create --title "Feature: Implement Global Hotkey Management for Stream Control" --body "## Description\nStreamers need to control their broadcast without switching focus away from their game or application. This feature enables users to assign global hotkeys to perform common Stream Buddy actions (e.g., switch scene, mute mic, start/stop stream, trigger alerts).\n\n## Acceptance Criteria\n- Users can configure global hotkeys within Stream Buddy's settings.\n- Hotkeys can be mapped to Stream Buddy actions (e.g., 'Switch to Scene 1', 'Toggle Mic Mute', 'Start Simulcast').\n- Hotkeys function even when Stream Buddy is not the active window (requires desktop application - Issue 6.2).\n- Hotkey registration and unregistration is reliable and doesn't conflict with OS hotkeys.\n\n## Technical Details\n- **Desktop Application (Issue 6.2):**\n  - Implement using Electron's `globalShortcut` module or OS-specific native APIs.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for hotkey configuration (detecting key presses, mapping actions).\n  - Backend API endpoints to receive hotkey configuration and trigger actions.\n\n## Best Practices\n- Clear conflict detection for hotkeys.\n- User-friendly hotkey setup interface.\n- Persistence of hotkey configurations (Issue 1.1)."
```

### **Issue 6.4: Feature: Dynamic Overlay Widgets (Scripting API)**

```bash
gh issue create --title "Feature: Implement Dynamic Overlay Widgets via Scripting API" --body "## Description\nAllow advanced users and developers to create custom overlay widgets using a scripting API (e.g., JavaScript). This enables highly customized visuals, interactivity, and integration with niche services not directly supported by Stream Buddy.\n\n## Acceptance Criteria:\n- Users can import/create custom JavaScript scripts for overlay widgets.\n- Scripts can interact with stream data (chat, events) via a provided API.\n- Widgets can draw directly onto a dedicated canvas layer or manipulate DOM elements within a web overlay (Issue 4.2).\n- A secure sandbox environment for script execution to prevent malicious code.\n- UI for managing and previewing custom scripts.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - **Script Execution:** Implement a secure JavaScript sandbox (e.g., using `iframe` with `sandbox` attributes, or a Web Worker) for custom widget scripts.\n  - **API Exposure:** Provide a limited API (e.g., `StreamBuddy.onEvent`, `StreamBuddy.drawCanvas`, `StreamBuddy.emitEvent`) for scripts to interact with Stream Buddy.\n  - `SceneCompositorService` integrates output from these scripts.\n- **WASM Opportunity:** If custom drawing operations or complex logic is needed in scripts, WASM modules could be exposed via the scripting API.\n\n## Best Practices:\n- Strict security sandboxing for user-provided scripts.\n- Clear documentation for the scripting API.\n- Version control and sharing mechanisms for widgets."
```

### **Issue 6.5: Enhancement: Stream Previews for All Scenes**

```bash
gh issue create --title "Enhancement: Provide Real-time Previews for All Configured Scenes" --body "## Description\nCurrently, only the active scene is fully rendered. This enhancement will provide real-time, low-resource previews for all configured scenes within Stream Buddy's UI, allowing streamers to prepare their next scene without affecting the live broadcast.\n\n## Acceptance Criteria:\n- The `SceneEditor` or a dedicated 'Scene Selector' UI displays small, live previews of all available scenes.\n- Previews update in real-time, reflecting changes to source positions, overlays, and filters within each scene.\n- Preview rendering is optimized to minimize CPU/GPU usage.\n- Switching to a scene from its preview initiates the configured scene transition (Issue 2.1).\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - `SceneCompositorService` is extended to manage multiple offscreen canvas contexts, one for each scene preview.\n  - Each offscreen canvas runs its own rendering loop at a lower frame rate.\n  - Use `OffscreenCanvas` API for rendering previews in Web Workers to prevent UI thread blocking.\n  - UI elements for displaying multiple scene previews.\n\n## Best Practices:\n- Efficient resource management for multiple canvas contexts.\n- Configurable preview quality/frame rate."
```

---

## Major Version 7: AI-Powered Stream Enhancement

### **Issue 7.1: Feature: AI-Powered Chat Moderation**

```bash
gh issue create --title "Feature: Implement AI-Powered Chat Moderation" --body "## Description\nEnhance chat moderation (Issue 3.4) with AI capabilities to automatically detect and flag spam, hate speech, inappropriate content, or malicious links in real-time across all integrated chat platforms.\n\n## Acceptance Criteria:\n- Integrate a pre-trained AI model (or a cloud-based AI service API) for text classification.\n- Chat messages from `StreamEventsGateway` are passed through the AI model.\n- AI-flagged messages are highlighted in the moderation UI and can be automatically acted upon (e.g., hide, warn, ban) based on user-defined sensitivity settings.\n- AI model provides a confidence score for its predictions.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - **AI Model Integration:** Options:\n    - **Cloud AI:** Integrate with Google Cloud Natural Language API, Azure Content Moderator, or similar.\n    - **Local AI (WASM/Python Microservice):** Deploy a lightweight, pre-trained text classification model (e.g., using TensorFlow.js or ONNX Runtime with a WASM backend, or a Python microservice with libraries like spaCy/Hugging Face). This could run locally if Stream Buddy becomes a desktop app (Issue 6.2).\n  - Extend `StreamEventsGateway` to forward chat messages to the AI service and process responses.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for configuring AI moderation sensitivity and auto-actions.\n  - Visual cues for flagged messages in chat display.\n\n## Best Practices\n- Prioritize user privacy (consider client-side processing for sensitive data).\n- Provide transparency on AI decisions.\n- Allow human override and feedback loop for model improvement."
```

### **Issue 7.2: Feature: AI-Driven Highlight & Clip Generation**

```bash
gh issue create --title "Feature: Implement AI-Driven Highlight and Clip Generation" --body "## Description\nAutomate the process of identifying and generating highlight clips from past VODs or live streams. AI can analyze stream events (e.g., high viewer engagement, chat spikes, specific game events, streamer's emotional cues) to pinpoint exciting moments.\n\n## Acceptance Criteria:\n- Backend analyzes stream data (e.g., chat activity, viewer count, event logs).\n- AI identifies potential highlight segments from recorded VODs (Issue 4.4).\n- Stream Buddy suggests highlight clips with start/end times.\n- Users can review, edit, and export suggested clips.\n- (Future) Real-time highlight marking based on AI suggestions.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - **Data Collection:** Log granular stream events (chat, viewer count, alerts) to the database.\n  - **AI Model:** Develop or integrate an AI model for event correlation and highlight detection (e.g., using Python/TensorFlow/PyTorch, potentially a microservice).\n  - **Video Processing:** Integrate `ffmpeg` (via WASM or native calls) for non-linear video editing (cutting clips).\n- **Frontend (`apps/stream-buddy`):**\n  - UI for viewing, editing, and exporting AI-generated clips.\n  - Playback of VODs with highlight markers.\n\n## Best Practices\n- User-configurable highlight criteria.\n- Fast and efficient video segment extraction.\n- Clear and informative UI for clip management."
```

### **Issue 7.3: Feature: AI-Powered Green Screen (Chroma Keying)**

```bash
gh issue create --title "Feature: Implement AI-Powered Green Screen (Chroma Keying) with Background Removal" --body "## Description\nProvide a robust and intelligent green screen (chroma keying) solution that can effectively remove backgrounds from webcam feeds, even without a physical green screen (using AI-driven segmentation), and allow for virtual backgrounds.\n\n## Acceptance Criteria:\n- Users can select a color key to remove from their webcam feed in `SceneEditor`.\n- Implement AI-driven background removal (person segmentation) without a green screen.\n- Users can choose virtual backgrounds (static images, video loops) to replace the removed background.\n- The effect is applied in real-time with high quality and minimal artifacts.\n- Performance is optimized for various hardware.\n\n## Technical Details\n- **Frontend (`libs/core/services/`):**\n  - **AI Model (WASM):** Integrate a lightweight, client-side AI segmentation model compiled to WASM (e.g., MediaPipe Selfie Segmentation, TensorFlow.js BodyPix). This would run in a Web Worker.\n  - `SceneCompositorService` rendering loop applies the segmentation mask to the webcam source.\n  - UI for selecting color key, sensitivity, and virtual backgrounds.\n\n## Best Practices\n- Prioritize privacy by performing AI processing client-side.\n- Optimize WASM model loading and inference for real-time performance.\n- Provide options for fine-tuning the segmentation mask."
```

### **Issue 7.4: Feature: AI-Assisted Scene Creation & Layout Suggestions**

```bash
gh issue create --title "Feature: Implement AI-Assisted Scene Creation and Layout Suggestions" --body "## Description\nLeverage AI to assist users in designing and optimizing their stream layouts. This feature would suggest optimal element placements, color schemes, and even generate basic scene templates based on user input or preferences.\n\n## Acceptance Criteria:\n- Users can provide input (e.g., stream type, game, preferred aesthetic).\n- AI suggests optimal placements for common elements (webcam, chat, alerts, game capture) for a balanced layout.\n- AI suggests complementary color palettes for overlays and background.\n- AI can generate basic scene templates that users can then customize.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Develop an AI model for layout generation (potentially rule-based or using basic machine learning for common patterns).\n  - Integrate with existing frontend element data.\n- **Frontend (`apps/stream-buddy`):**\n  - `SceneEditor` UI to interact with AI suggestions.\n  - Algorithm for assessing layout balance and visual appeal.\n\n## Best Practices\n- User-centric design for AI suggestions (suggestions, not).\n- Provide clear explanations for AI choices.\n- Iterative feedback loop for AI model improvement."
```

### **Issue 7.5: Feature: Automated Live Captioning / Transcription (WASM/Cloud AI)**

```bash
gh issue create --title "Feature: Implement Automated Live Captioning / Transcription" --body "## Description\nProvide real-time, automated captions (transcription) of the streamer's audio, which can be displayed as a text overlay on the stream. This greatly enhances accessibility for viewers and can be useful for post-stream VOD transcription.\n\n## Acceptance Criteria:\n- Streamer's microphone audio is transcribed into text in real-time.\n- Transcribed text can be displayed as a customizable text overlay (Issue 2.4.2).\n- Transcription is accurate and low-latency.\n- Users can enable/disable live captioning and configure its appearance.\n\n## Technical Details\n- **Frontend (`libs/core/services/`):**\n  - **Speech-to-Text (STT) Engine:** Options:\n    - **Cloud STT:** Integrate with Google Cloud Speech-to-Text, AWS Transcribe, or Azure Speech Service (requires backend proxy for API keys).\n    - **Client-side STT (WASM):** Use a lightweight STT model compiled to WASM (e.g., WebAssembly-powered Whisper.cpp or Vosk.js for browser-based, offline transcription). This would run in an `AudioWorkletProcessor` or Web Worker.\n  - `AudioMixerService` provides the processed microphone audio stream to the STT engine.\n  - `OverlayRendererService` manages the text overlay for captions.\n\n## Best Practices\n- Prioritize privacy for audio input.\n- Optimize STT processing for low latency.\n- Provide options for language selection and error correction."
```

---

### **Major Version 8: Advanced Platform Integration & API**

#### **Issue 8.1: Feature: Multi-Platform Viewer Statistics Aggregation**

```bash
gh issue create --title "Feature: Implement Unified Multi-Platform Viewer Statistics Aggregation" --body "## Description\nProvide a consolidated view of viewer statistics across all simultaneously streaming platforms (Twitch, YouTube, custom RTMP). This gives streamers a complete picture of their audience engagement.\n\n## Acceptance Criteria:\n- Backend fetches real-time viewer counts, chat activity, and other engagement metrics from Twitch, YouTube, and other integrated platforms.\n- Data from all platforms is aggregated and normalized.\n- UI displays total concurrent viewers, chat rates, and platform-specific breakdowns in a unified dashboard.\n- Historical viewer data is logged and visualized (Issue 3.5).\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Extend `TwitchAuthService` and `YoutubeAuthService` to fetch relevant viewer statistics via platform APIs.\n  - Implement polling or webhook-based mechanisms for data collection.\n  - Create a new `StatsAggregationService` to normalize and store data.\n- **Frontend (`apps/stream-buddy`):**\n  - UI components for displaying real-time and historical aggregated statistics.\n\n## Best Practices\n- Efficient data polling to avoid API rate limits.\n- Clear data visualization.\n- Data privacy considerations for viewer statistics."
```

#### **Issue 8.2: Feature: Stream Categories & Tags Management**

```bash
gh issue create --title "Feature: Implement Comprehensive Stream Categories and Tags Management" --body "## Description\nAllow streamers to easily manage and set relevant categories, games, and tags for their stream across all platforms, optimizing discoverability and audience targeting.\n\n## Acceptance Criteria:\n- UI provides a centralized interface to search for and select categories/tags relevant to each platform.\n- Users can set default categories/tags per stream profile.\n- Metadata updates (Issue 1.4) include support for updating categories and tags via platform APIs.\n- UI provides auto-completion and suggestions for categories/tags based on platform data.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Extend `TwitchAuthService` and `YoutubeAuthService` to fetch available categories/tags from platform APIs.\n  - Implement endpoints for searching and applying categories/tags.\n- **Frontend (`apps/stream-buddy`):**\n  - UI components with search, selection, and auto-completion for categories/tags.\n\n## Best Practices\n- Keep platform-specific category/tag rules in mind.\n- User-friendly search and selection experience."
```

#### **Issue 8.3: Feature: Custom RTMP/RTMPS Endpoint Management**

```bash
gh issue create --title "Feature: Implement Robust Custom RTMP/RTMPS Endpoint Management" --body "## Description\nEnhance the existing custom RTMP destination functionality to support a wider range of custom endpoints, including RTMPS for secure connections, and advanced configurations commonly used by smaller streaming services.\n\n## Acceptance Criteria:\n- Users can add custom RTMP/RTMPS URLs and stream keys.\n- Option for SSL/TLS encryption for RTMPS streams.\n- Backend (`SimulcastService`) correctly configures MediaMTX to publish to these secure custom endpoints.\n- UI validates custom URL formats and secure connection requirements.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Update `StreamDestination` (Issue 1.2) to include RTMPS-specific options.\n  - `SimulcastService.buildFfmpegCommand` generates appropriate `ffmpeg` commands for RTMPS.\n- **Frontend (`apps/stream-buddy`):**\n  - UI fields for RTMPS options (e.g., certificate paths, if applicable).\n\n## Best Practices:\n- Secure storage of custom stream keys (Issue 1.1).\n- Clear error messages for invalid custom configurations."
```

#### **Issue 8.4: Feature: Stream Deck / Companion App Integration**

```bash
gh issue create --title "Feature: Implement Stream Deck / Companion App Integration" --body "## Description\nEnable integration with hardware stream decks (e.g., Elgato Stream Deck) or develop a dedicated mobile companion app to provide tactile and remote control over Stream Buddy's features.\n\n## Acceptance Criteria:\n- Users can connect their Stream Deck device or companion app to Stream Buddy.\n- Stream Deck buttons can be mapped to Stream Buddy actions (e.g., scene switch, mute mic, trigger alert, start/stop stream).\n- Companion app provides remote control functionality for core features.\n- Integration is responsive and reliable.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Implement a dedicated API (e.g., WebSocket-based) for Stream Deck/companion app communication.\n  - Expose actions that can be triggered remotely.\n- **Desktop Application (Issue 6.2):**\n  - Develop Stream Deck plugin using Elgato SDK.\n  - Develop simple mobile companion app (e.g., using Flutter/React Native) that connects to the local Stream Buddy backend/desktop app.\n\n## Best Practices:\n- Secure communication between Stream Buddy and companion devices.\n- Intuitive mapping interface for actions."
```

#### **Issue 8.5: Enhancement: Stream Pre-Flight Check & Diagnostics**

```bash
gh issue create --title "Enhancement: Implement Stream Pre-Flight Check and Diagnostics Tools" --body "## Description\nBefore going live, streamers need to verify their setup. This feature will provide a 'pre-flight check' system to diagnose potential issues (e.g., internet connection stability, microphone levels, webcam detected, MediaMTX connectivity) and suggest solutions.\n\n## Acceptance Criteria:\n- Stream Buddy performs automated checks before starting a stream (e.g., network speed test, microphone input levels, camera detection, MediaMTX API response).\n- UI displays a clear report of potential issues and actionable recommendations.\n- Real-time diagnostic tools are available during a stream to troubleshoot problems.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - Implement network speed tests (e.g., WebRTC stats for bandwidth).\n  - `MediaCaptureService` provides detailed device status.\n  - `StreamMonitoringService` (Issue 1.5) aggregates diagnostic data.\n  - UI for pre-flight checklist and live diagnostics.\n\n## Best Practices:\n- Clear, user-friendly diagnostic messages.\n- Integrate with OS-level diagnostics where possible (desktop app, Issue 6.2).\n- Continuous monitoring for critical issues during live stream."
```

---

## Major Version 9: VOD Management & Content Creation

### **Issue 9.1: Feature: Integrated VOD Editor (Basic Trimming & Cutting)**

```bash
gh issue create --title "Feature: Implement Basic Integrated VOD Editor (Trimming and Cutting)" --body "## Description\nExpand on local recording (Issue 4.4) by providing a basic, integrated video editor for VODs. This will allow streamers to quickly trim and cut unwanted sections from their recorded broadcasts before sharing or uploading.\n\n## Acceptance Criteria:\n- Users can import local recordings into the VOD editor.\n- A simple timeline interface allows setting start and end points for trimming.\n- Users can cut out multiple segments from a single VOD.\n- Edited VODs can be exported to a new file in a standard format (e.g., MP4).\n- Editing operations are non-destructive to the original recording.\n\n## Technical Details\n- **Frontend (`apps/stream-buddy`):**\n  - **Video Playback:** Use HTML5 `<video>` element.\n  - **Timeline UI:** Implement a simple interactive timeline component.\n  - **Editing Engine (WASM/JS):** Utilize a client-side video editing library (e.g., `FFmpeg.wasm` for trimming/cutting, or a custom WebAssembly module for video processing). This can run in a Web Worker.\n  - UI for setting in/out points, previewing edits, and exporting.\n\n## Best Practices:\n- Responsive timeline interaction.\n- Efficient client-side video processing.\n- Clear visual feedback during editing."
```

### **Issue 9.2: Feature: VOD Chapter Markers & Event Timestamps**

```bash
gh issue create --title "Feature: Implement VOD Chapter Markers and Event Timestamps" --body "## Description\nEnhance VODs (Video On Demand) by automatically or manually adding chapter markers and timestamps for key stream events (e.g., highlight moments, game switches, raid starts). This improves VOD navigability and discoverability.\n\n## Acceptance Criteria:\n- Stream Buddy automatically logs timestamps for significant events during a live stream (e.g., scene changes, major alerts, manual markers).\n- Users can manually add chapter markers during a live stream or during VOD editing.\n- VOD editor UI displays these markers on the timeline (Issue 9.1).\n- Exported VODs or associated metadata include chapter information (e.g., for YouTube chapters).\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Store event timestamps in the database (Issue 1.1) linked to recorded VODs.\n- **Frontend (`apps/stream-buddy`):**\n  - `StreamMonitoringService` (Issue 1.5) logs event timestamps.\n  - VOD editor UI integrates markers onto the timeline (Issue 9.1).\n  - UI for manual marker creation (e.g., hotkey trigger).\n\n## Best Practices:\n- Accurate timestamp logging.\n- User-friendly interface for marker management.\n- Compatibility with platform-specific chapter formats."
```

### **Issue 9.3: Feature: Automatic Social Media Snippet Generation**

```bash
gh issue create --title "Feature: Implement Automatic Social Media Snippet Generation" --body "## Description\nHelp streamers promote their content by automating the creation of short, shareable video snippets for social media platforms (e.g., TikTok, Instagram Reels, YouTube Shorts) from their VODs or highlights.\n\n## Acceptance Criteria:\n- Users can select a highlight segment (Issue 7.2 or 9.1).\n- Stream Buddy offers options to automatically reformat the clip for different social media platforms (e.g., aspect ratio, duration).\n- Clips can be exported or directly uploaded to connected social media accounts (future enhancement).\n- Basic text overlays/branding can be added to snippets.\n\n## Technical Details\n- **Frontend (`apps/stream-buddy`):**\n  - UI for selecting highlight segments and social media targets.\n  - Preview of reformatted clips.\n- **Backend (`apps/api`):**\n  - **Video Processing (WASM/Microservice):** Utilize `ffmpeg` (WASM or server-side microservice) for video re-encoding, resizing, and cropping to platform-specific aspect ratios.\n  - Implement integration with social media APIs for direct upload (e.g., YouTube Shorts API, TikTok API).\n\n## Best Practices:\n- Adhere to social media platform video specifications.\n- Provide templates for common social media formats.\n- Focus on performance for video processing."
```

### **Issue 9.4: Feature: Multi-Track Audio Recording & Editing**

```bash
gh issue create --title "Feature: Implement Multi-Track Audio Recording and Basic Editing" --body "## Description\nProfessional streamers often require separate audio tracks for their microphone, game audio, and alerts, to allow for more flexible post-production editing. This feature will enable multi-track audio recording and basic editing capabilities.\n\n## Acceptance Criteria:\n- Local recordings (Issue 4.4) can capture multiple audio tracks simultaneously (e.g., mic, desktop audio, alerts) into a single file (e.g., MKV container) or separate files.\n- VOD editor (Issue 9.1) allows users to view and perform basic edits (e.g., adjust volume, mute) on individual audio tracks.\n- Exported VODs retain multi-track audio or allow mixing down to a stereo track.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - `MediaRecorder API` can capture multiple audio tracks into a `MediaStream` if sources are connected correctly.\n  - `AudioMixerService` needs to manage individual audio tracks for recording separately.\n  - VOD editor UI (Issue 9.1) is enhanced with multi-track audio display.\n- **WASM Opportunity:** For complex audio track manipulation or muxing into specific containers, WASM-compiled libraries could be used.\n\n## Best Practices:\n- Efficient handling of multiple audio streams.\n- Clear visual representation of audio tracks in the editor.\n- Non-destructive audio editing."
```

### **Issue 9.5: Enhancement: Stream Recap & Analytics Reports**

```bash
gh issue create --title "Enhancement: Provide Post-Stream Recap and Analytics Reports" --body "## Description\nLeverage collected stream data (Issue 3.5, 8.1) to generate comprehensive post-stream reports, offering insights into audience engagement, peak moments, chat trends, and overall performance across all platforms.\n\n## Acceptance Criteria:\n- Stream Buddy generates a summary report after each stream, accessible from a 'Past Streams' dashboard.\n- Reports include key metrics: total viewership, peak viewers, average viewers, total chat messages, top chatters, follower/subscriber growth.\n- Reports offer insights into overlay effectiveness (e.g., which alerts triggered most engagement).\n- Data is presented in clear, interactive charts and graphs.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Extend `StatsAggregationService` (Issue 8.1) to process and summarize historical data.\n  - Implement API endpoints for retrieving historical stream data and reports.\n- **Frontend (`apps/stream-buddy`):**\n  - Dedicated 'Past Streams' dashboard UI.\n  - Integration of charting libraries (e.g., Chart.js, D3.js) for data visualization.\n\n## Best Practices:\n- Clear and actionable insights.\n- Customizable report parameters.\n- Secure storage and display of sensitive analytics data."
```

---

## Major Version 10: Advanced Interactivity & Community Tools

### **Issue 10.1: Feature: Polls & Q&A Integration**

```bash
gh issue create --title "Feature: Implement Integrated Polls and Q&A System" --body "## Description\nEnable streamers to run interactive polls and host Q&A sessions directly through Stream Buddy, with results and questions integrated into overlays and platform chats.\n\n## Acceptance Criteria:\n- Users can create and launch polls with multiple choices.\n- Poll results are displayed as a dynamic overlay (Issue 2.4.2) and/or in platform chats.\n- Users can initiate Q&A sessions, collecting questions from chat.\n- Selected questions can be displayed as an overlay for the stream.\n- Backend API manages poll data and Q&A queues.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Implement API for poll creation, voting, and result aggregation.\n  - Integrate with Twitch/YouTube chat APIs for voting via chat commands.\n  - Store poll and Q&A data in the database (Issue 1.1).\n- **Frontend (`apps/stream-buddy`):**\n  - UI for poll creation and management.\n  - `OverlayRendererService` and `SceneCompositorService` draw poll/Q&A overlays.\n  - Chat integration for voting/asking.\n\n## Best Practices:\n- Real-time updates for poll results.\n- Clear moderation tools for Q&A questions.\n- User-friendly poll creation interface."
```

### **Issue 10.2: Feature: Viewer Games / Interactive Extensions**

```bash
gh issue create --title "Feature: Implement Viewer Games and Interactive Extensions" --body "## Description\nDevelop a framework for creating and integrating simple viewer games or interactive extensions that can run alongside the stream, engaging the audience directly within the Stream Buddy ecosystem.\n\n## Acceptance Criteria:\n- Stream Buddy provides a mechanism to embed or create simple interactive games (e.g., mini-games like clicker games, trivia).\n- Viewer input (e.g., chat commands, web interaction) can influence the game.\n- Game state can be displayed as an overlay (Issue 2.4.2).\n- (Future) Integrates with Twitch Extensions API for deeper platform interaction.\n\n## Technical Details\n- **Frontend (`apps/stream-buddy`):**\n  - **Game Engine (WASM/JS):** Use a lightweight game engine (e.g., Phaser.js, Three.js, or custom WASM game logic) to create interactive elements.\n  - `StreamEventsGateway` (backend) can relay chat commands/events to games.\n  - UI for managing game instances and settings.\n\n## Best Practices:\n- High performance for embedded games.\n- Secure execution of game logic.\n- Clear communication of game rules to viewers."
```

### **Issue 10.3: Feature: AI-Driven Audience Engagement Insights**

```bash
gh issue create --title "Feature: Implement AI-Driven Audience Engagement Insights" --body "## Description\nLeverage AI to provide streamers with deeper insights into their audience's behavior and preferences, suggesting optimal content strategies and engagement tactics.\n\n## Acceptance Criteria:\n- AI analyzes chat sentiment, viewer retention, and interaction patterns (e.g., poll participation, alert triggers).\n- Stream Buddy provides AI-generated recommendations for: best times to stream, content topics, viewer interaction strategies.\n- UI displays sentiment analysis of chat.\n- (Future) Real-time AI suggestions for streamer actions.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - **AI Model:** Develop or integrate an AI model for sentiment analysis, topic modeling, and recommendation systems.\n  - Process historical stream data (Issue 9.5) to train and apply AI models.\n- **Frontend (`apps/stream-buddy`):**\n  - Dashboard for AI insights and recommendations.\n  - Visualization of chat sentiment over time.\n\n## Best Practices:\n- Ethical AI design, avoiding bias.\n- Clear explanation of AI models and their outputs.\n- Focus on actionable insights for streamers."
```

### **Issue 10.4: Feature: Multi-Language Stream Support (Captions & Chat)**

```bash
gh issue create --title "Feature: Implement Multi-Language Stream Support (Captions & Chat Translation)" --body "## Description\nExpand accessibility and global reach by offering multi-language support, including real-time translation of captions (Issue 7.5) and chat messages.\n\n## Acceptance Criteria:\n- Users can select a primary broadcast language and target translation languages.\n- Live captions (Issue 7.5) are translated in real-time to selected languages and displayed as an overlay.\n- Chat messages from different languages are translated to the streamer's primary language (and vice versa for outgoing messages).\n- UI provides language selection and translation configuration.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - **Translation API:** Integrate with cloud-based translation services (e.g., Google Translate API, DeepL API).\n  - Route chat and caption data through translation services.\n- **Frontend (`apps/stream-buddy`, `libs/core/services/`):**\n  - `OverlayRendererService` manages multi-language caption overlays.\n  - `StreamEventsGateway` (backend) emits translated chat messages.\n\n## Best Practices:\n- Prioritize translation accuracy and low latency.\n- Provide clear indications of translated content.\n- Handle character sets and text rendering for various languages."
```

### **Issue 10.5: Enhancement: Custom Branding & Theming**

```bash
gh issue create --title "Enhancement: Custom Branding and Theming for Stream Buddy UI" --body "## Description\nAllow users to customize the appearance of the Stream Buddy application itself (beyond just stream overlays), enabling them to brand their entire production environment.\n\n## Acceptance Criteria:\n- Users can select from pre-defined themes.\n- Users can customize primary/secondary colors, fonts, and background images for the Stream Buddy UI.\n- Theme settings are persistent (Issue 1.1).\n- Customization options are applied consistently across the application.\n\n## Technical Details\n- **Frontend (`apps/stream-buddy`):**\n  - Implement a CSS custom properties (variables) based theming system.\n  - UI for theme selection and customization.\n  - Store theme preferences in user settings (Issue 1.1).\n\n## Best Practices:\n- Accessible color contrast for all themes.\n- Modular CSS architecture for easy theme switching.\n- Live preview of theme changes."
```

---

## Major Version 11: Monetization & Community Building

### **Issue 11.1: Feature: Subscription & Tier-Based Content/Features**

```bash
gh issue create --title "Feature: Implement Subscription and Tier-Based Content/Features" --body "## Description\nEnable streamers to offer exclusive content or features within Stream Buddy based on viewer subscriptions or tiers (e.g., custom alerts, exclusive overlays, private chat access). This leverages platform subscription APIs.\n\n## Acceptance Criteria:\n- Stream Buddy integrates with Twitch/YouTube subscription APIs to identify active subscribers and their tiers.\n- Users can define specific overlay elements or features that are only visible/active for certain subscription tiers.\n- Backend API enforces access control for tier-based features.\n- Frontend UI reflects viewer's subscription status and unlocks features accordingly.\n\n## Technical Details:\n- **Backend (`apps/api`):**\n  - Extend `TwitchAuthService` and `YoutubeAuthService` to track subscriber status.\n  - Implement API endpoints for checking user subscription tiers.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for configuring tier-based content.\n  - `SceneCompositorService` (or `OverlayRendererService`) dynamically renders elements based on viewer tier.\n\n## Best Practices:\n- Secure identification of subscriber status.\n- Clear communication of tier benefits to viewers.\n- Flexible configuration for exclusive content."
```

### **Issue 11.2: Feature: Integrated Merch Store / Affiliate Links**

```bash
gh issue create --title "Feature: Implement Integrated Merch Store / Affiliate Link Display" --body "## Description\nHelp streamers monetize their content by integrating tools to display their merchandise store links or affiliate product links directly into their stream overlays and chat.\n\n## Acceptance Criteria:\n- Users can configure links to their merchandise stores or affiliate products.\n- These links can be displayed as clickable overlays (Issue 2.4.2) or periodically posted in chat.\n- UI provides analytics on link clicks or overlay impressions.\n- (Future) Direct integration with e-commerce APIs to display product inventory/details.\n\n## Technical Details:\n- **Backend (`apps/api`):**\n  - Implement API for storing and tracking merch/affiliate links.\n  - Potentially integrate with e-commerce APIs (e.g., Shopify, WooCommerce).\n- **Frontend (`apps/stream-buddy`):**\n  - UI for configuring merch/affiliate links.\n  - `OverlayRendererService` and `SceneCompositorService` display dynamic links.\n  - Chatbot integration for automatic link posting (Issue 3.4).\n\n## Best Practices:\n- Non-intrusive display of promotional content.\n- Accurate tracking of engagement metrics.\n- User-friendly configuration of links."
```

### **Issue 11.3: Feature: Subscriber/Follower Goal Overlays**

```bash
gh issue create --title "Feature: Implement Dynamic Subscriber/Follower Goal Overlays" --body "## Description\nProvide visually engaging overlays that display progress towards subscriber or follower goals, incentivizing viewers to help the streamer reach their milestones.\n\n## Acceptance Criteria:\n- Users can set follower/subscriber goals for connected platforms.\n- Stream Buddy fetches real-time follower/subscriber counts.\n- Goal progress is displayed as a dynamic overlay (Issue 2.4.2) (e.g., progress bar, animated counter).\n- UI for setting goals and customizing overlay appearance.\n\n## Technical Details:\n- **Backend (`apps/api`):**\n  - Extend `TwitchAuthService` and `YoutubeAuthService` to fetch follower/subscriber counts (Issue 8.1).\n  - Store goal configurations (Issue 1.1).\n- **Frontend (`apps/stream-buddy`, `libs/core/services/`):**\n  - UI for goal setup.\n  - `OverlayRendererService` and `SceneCompositorService` draw dynamic goal overlays.\n\n## Best Practices:\n- Visually appealing and customizable goal displays.\n- Real-time updates for progress.\n- Clear goal definition and management."
```

### **Issue 11.4: Feature: Community Spotlight / Viewer Queue System**

```bash
gh issue create --title "Feature: Implement Community Spotlight / Viewer Queue System" --body "## Description\nBuild tools to engage the community by allowing streamers to spotlight loyal viewers or manage a queue for viewer participation in games or Q&A sessions.\n\n## Acceptance Criteria:\n- Users can add viewers to a 'spotlight' queue or manually select a viewer to feature.\n- The selected viewer's name/profile can be displayed as an overlay (Issue 2.4.2).\n- Implement a queue system for viewers to sign up for participation (e.g., to play a game with the streamer).\n- UI for managing queues and selecting viewers.\n\n## Technical Details:\n- **Backend (`apps/api`):**\n  - Implement API for managing viewer queues and spotlight status.\n  - Potentially integrate with platform APIs for viewer data.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for queue management, viewer selection.\n  - `OverlayRendererService` and `SceneCompositorService` display spotlight/queue overlays.\n\n## Best Practices:\n- Fair and transparent queue management.\n- Respect viewer privacy.\n- Intuitive UI for interaction."
```

### **Issue 11.5: Enhancement: Stream Team / Group Management Integration**

```bash
gh issue create --title "Enhancement: Integrate Stream Team / Group Management" --body "## Description\nFor streamers who are part of teams or content groups, Stream Buddy should integrate with platform-specific team features (e.g., Twitch Teams) to facilitate easier collaboration and promotion.\n\n## Acceptance Criteria:\n- Users can connect their Stream Buddy account to a Twitch Team.\n- Stream Buddy can display team members, their live status, and shared goals.\n- (Future) Shared scene assets or collaborative editing within a team.\n\n## Technical Details:\n- **Backend (`apps/api`):**\n  - Extend `TwitchAuthService` to access team-related endpoints.\n  - Store team information (Issue 1.1).\n- **Frontend (`apps/stream-buddy`):**\n  - UI for connecting to and managing team memberships.\n  - Display of team member streams.\n\n## Best Practices:\n- Secure handling of team data.\n- Clear permissions for team interactions.\n- Compliance with platform team features."
```

---

## Major Version 12: Advanced Accessibility & Localization

### **Issue 12.1: Feature: Streamer-Controlled Accessibility Options**

```bash
gh issue create --title "Feature: Implement Streamer-Controlled Accessibility Options for Viewers" --body "## Description\nProvide streamers with tools to make their broadcasts more accessible to viewers with disabilities. This includes customizable caption appearance, audio description toggles, and visual aid adjustments.\n\n## Acceptance Criteria:\n- Streamers can configure caption font, size, color, and background (Issue 7.5).\n- Streamers can provide simple audio descriptions or text alternatives for visual content.\n- Frontend UI for configuring these accessibility options.\n- (Future) Viewers can opt-in to these features via a custom web extension or integrated player.\n\n## Technical Details:\n- **Frontend (`apps/stream-buddy`, `libs/core/services/`):**\n  - `OverlayRendererService` and `SceneCompositorService` draw captions with customizable styles.\n  - UI for accessibility settings.\n- **Backend (`apps/api`):**\n  - Store accessibility preferences (Issue 1.1).\n  - Potentially provide an API for external viewers to request accessibility features.\n\n## Best Practices:\n- Adhere to WCAG guidelines for accessibility.\n- Prioritize user-friendly controls for accessibility features.\n- Clear communication of available options to viewers."
```

### **Issue 12.2: Feature: Multi-Language Application UI**

```bash
gh issue create --title "Feature: Implement Multi-Language Application UI (Localization)" --body "## Description\nMake Stream Buddy's user interface available in multiple languages, improving usability for a global audience of streamers.\n\n## Acceptance Criteria:\n- Users can select their preferred language for the Stream Buddy UI.\n- All static text elements, labels, and messages in the application are translated.\n- Language preferences are persistent (Issue 1.1).\n- (Future) Dynamic content (e.g., tooltips) is also localized.\n\n## Technical Details\n- **Frontend (`apps/stream-buddy`):**\n  - Integrate Angular's built-in i18n tools (`@angular/localize`).\n  - Create translation files (XLIFF, JSON) for supported languages.\n  - Implement language switching mechanism.\n\n## Best Practices:\n- Use a professional translation workflow.\n- Ensure UI elements adapt to different text lengths and directions.\n- Provide a comprehensive set of supported languages."
```

### **Issue 12.3: Feature: Dynamic Font Management for Overlays**

```bash
gh issue create --title "Feature: Implement Dynamic Font Management for Overlays" --body "## Description\nAllow streamers to upload and use custom fonts for their text overlays (Issue 2.4.2), providing greater creative control and branding opportunities.\n\n## Acceptance Criteria:\n- Users can upload custom font files (e.g., TTF, OTF).\n- Uploaded fonts are available for selection in `OverlayEditorComponent` for text elements.\n- `SceneCompositorService` can render text using these custom fonts.\n- Custom fonts are correctly displayed in the live stream.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Implement API for secure font file uploads and storage (Issue 5.4).\n- **Frontend (`apps/stream-buddy`, `libs/core/services/`):**\n  - Font loading mechanism for `SceneCompositorService` (e.g., `@font-face` injection into canvas context).\n  - UI for font upload and selection.\n\n## Best Practices:\n- Handle font licensing and usage rights.\n- Efficient font loading to avoid performance issues.\n- Support for various font formats."
```

### **Issue 12.4: Feature: Auditory Alerts for Streamer (Private)**

```bash
gh issue create --title "Feature: Implement Private Auditory Alerts for Streamer" --body "## Description\nBeyond visual alerts on stream, provide private auditory alerts to the streamer for critical events (e.g., new follower, super chat, stream health warning) that are not broadcast to viewers.\n\n## Acceptance Criteria:\n- Users can configure specific events to trigger private audio cues.\n- Audio cues are played only for the streamer, not mixed into the live stream output.\n- UI for configuring alert sounds and events.\n- (Future) Customizable audio files for alerts.\n\n## Technical Details\n- **Frontend (`apps/stream-buddy`, `libs/core/services/`):**\n  - `OverlayRendererService` (or a dedicated `StreamerAlertsService`) listens to `StreamEventsGateway` for events.\n  - Uses Web Audio API to play sounds directly in the streamer's browser (not mixed into `SceneCompositorService`).\n  - UI for alert sound selection and volume.\n\n## Best Practices:\n- Clear distinction between public and private audio.\n- Customizable and unobtrusive alert sounds.\n- Prioritize low latency for critical alerts."
```

### **Issue 12.5: Enhancement: Customizable UI Layouts & Workspaces**

```bash
gh issue create --title "Enhancement: Implement Customizable UI Layouts and Workspaces" --body "## Description\nAllow advanced users to customize the layout of Stream Buddy's UI panels and create different workspaces tailored for specific tasks (e.g., a 'Streaming' workspace, an 'Editing' workspace).\n\n## Acceptance Criteria:\n- Users can drag, resize, and dock UI panels (e.g., chat, preview, mixer, scene selector).\n- Users can save and load custom UI layouts as 'workspaces'.\n- Switching workspaces reconfigures the UI layout.\n- Layouts are persistent (Issue 1.1).\n\n## Technical Details\n- **Frontend (`apps/stream-buddy`):**\n  - Integrate an Angular-compatible layout management library (e.g., `ngx-layout`, custom drag-and-drop).\n  - Store layout configurations in user settings (Issue 1.1).\n  - UI for managing workspaces.\n\n## Best Practices:\n- Intuitive drag-and-drop interaction.\n- Responsive layout adaptation.\n- Persistence and easy switching between workspaces."
```

---

## Major Version 13: Advanced Media Assets & Automation

### **Issue 13.1: Feature: Video Playback & Media Player Source**

```bash
gh issue create --title "Feature: Implement Dedicated Video Playback / Media Player Source" --body "## Description\nAllow streamers to play local video files or integrate with video hosting services (e.g., Vimeo, YouTube) as a dedicated media player source within their scenes, enabling VOD playback, intro/outro videos, or short clips.\n\n## Acceptance Criteria:\n- Users can add local video files or external video URLs as a media player source.\n- Media player source can be controlled (play/pause, seek, volume) from Stream Buddy.\n- Output of the media player is integrated into `SceneCompositorService`.\n- UI for media player controls and playlist management.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - Create a new `MediaPlayerService` that manages HTML5 `<video>` elements.\n  - `SceneCompositorService` integrates output from `MediaPlayerService`.\n  - UI for media library, controls, and playlist.\n\n## Best Practices:\n- Efficient video decoding and playback.\n- Smooth integration into scene composition.\n- Support for common video formats."
```

### **Issue 13.2: Feature: Image Slideshow / Carousel Source**

```bash
gh issue create --title "Feature: Implement Image Slideshow / Carousel Source" --body "## Description\nProvide a dedicated source type for image slideshows or carousels, allowing streamers to cycle through a collection of images (e.g., sponsor logos, fan art, educational slides) within their scenes.\n\n## Acceptance Criteria:\n- Users can create image slideshows from uploaded images (Issue 5.4).\n- Slideshows can be configured with transition effects, display duration, and order.\n- Output of the slideshow is integrated into `SceneCompositorService`.\n- UI for slideshow creation and management.\n\n## Technical Details\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - Create a new `SlideshowService` that manages image transitions on an internal canvas or `<img>` elements.\n  - `SceneCompositorService` integrates output from `SlideshowService`.\n  - UI for slideshow configuration.\n\n## Best Practices:\n- Smooth image transitions.\n- Optimized image loading and caching.\n- Configurable control over slideshow timing."
```

### **Issue 13.3: Feature: Streamer Branding & Overlays Automation**

```bash
gh issue create --title "Feature: Implement Streamer Branding & Overlays Automation" --body "## Description\nAutomate the application of streamer branding elements and overlay changes based on predefined rules or stream events, reducing manual effort during live broadcasts.\n\n## Acceptance Criteria:\n- Users can define rules (e.g., 'every 10 minutes, show sponsor logo for 30 seconds').\n- Users can link overlays or scenes to specific events (e.g., 'on 100th follower, show celebratory overlay').\n- Stream Buddy automatically triggers these changes.\n- UI for defining automation rules and linking them to events/timers.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Implement a rule engine for event-driven automation.\n  - Integrate with `StreamEventsGateway` for event triggers.\n  - Store automation rules (Issue 1.1).\n- **Frontend (`apps/stream-buddy`):**\n  - UI for creating and managing automation rules.\n  - `StreamOrchestrationService` (or new service) executes automated changes to `SceneCompositorService`.\n\n## Best Practices:\n- Intuitive rule creation interface.\n- Reliable and timely execution of automated actions.\n- Conflict resolution for overlapping rules."
```

### **Issue 13.4: Feature: Interactive Whiteboard / Drawing Overlay**

```bash
gh issue create --title "Feature: Implement Interactive Whiteboard / Drawing Overlay" --body "## Description\nProvide a dedicated whiteboard or drawing canvas overlay that streamers can use to annotate, illustrate, or draw in real-time during their broadcast, enhancing educational content or commentary.\n\n## Acceptance Criteria:\n- Users can add an interactive drawing canvas as an overlay (Issue 2.4.2).\n- Streamers can draw, erase, and change colors/pen sizes on this canvas.\n- Drawing actions are rendered in real-time onto the `SceneCompositorService` output.\n- UI for drawing tools and settings.\n\n## Technical Details\n- **Frontend (`apps/stream-buddy`, `libs/core/services/`):**\n  - Implement a drawing canvas using `CanvasRenderingContext2D` or a library like `Fabric.js`.\n  - `OverlayRendererService` manages the drawing overlay.\n  - `SceneCompositorService` integrates the drawing canvas as a source.\n\n## Best Practices:\n- Low-latency drawing responsiveness.\n- Intuitive drawing tools.\n- Clear/save drawing functionality."
```

### **Issue 13.5: Enhancement: Streamer Presence / Away Status Automation**

```bash
gh issue create --title "Enhancement: Implement Streamer Presence / Away Status Automation" --body "## Description\nAutomate changes to stream status (e.g., switching to 'Be Right Back' scene, updating Discord status, changing platform status) when the streamer is detected as away from keyboard (AFK) or when the stream starts/ends.\n\n## Acceptance Criteria:\n- Stream Buddy detects streamer AFK status (e.g., no keyboard/mouse input for X minutes, no mic activity).\n- Configurable actions trigger on AFK detection (e.g., switch to BRB scene, post message in chat).\n- Automated status updates for Discord, Twitch, etc.\n- Users can manually override AFK status.\n\n## Technical Details\n- **Desktop Application (Issue 6.2):**\n  - Implement OS-level input monitoring for AFK detection.\n- **Backend (`apps/api`):**\n  - Implement API for updating Discord/platform statuses.\n  - Store automation rules (Issue 1.1).\n- **Frontend (`apps/stream-buddy`):**\n  - UI for configuring AFK rules and actions.\n  - `StreamOrchestrationService` (or new service) integrates with AFK detection to trigger scene/status changes.\n\n## Best Practices:\n- Reliable AFK detection.\n- User-configurable sensitivity and actions.\n- Clear feedback on automated status changes."
```

---

## Major Version 14: Deep Integrations & Advanced Control

### **Issue 14.1: Feature: Full Twitch/YouTube/Other Platform Chatbot Integration**

```bash
gh issue create --title "Feature: Implement Full Twitch/YouTube/Other Platform Chatbot Integration" --body "## Description\nIntegrate advanced chatbot functionality, allowing streamers to run custom commands, scheduled messages, viewer games (Issue 10.2), and moderation actions (Issue 7.1) directly through Stream Buddy's own chatbot.\n\n## Acceptance Criteria:\n- Users can configure custom chat commands (e.g., `!socials`, `!uptime`).\n- Chatbot responds to commands in platform chats.\n- Chatbot can post scheduled messages.\n- Integrates with viewer games and loyalty systems.\n- Backend API manages chatbot configuration and execution.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Create `ChatbotModule` to manage chatbot instances for each platform.\n  - Implement connection to Twitch IRC, YouTube Live Chat API.\n  - Develop command parser and response logic.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for chatbot command creation, scheduling, and configuration.\n\n## Best Practices:\n- Reliable and performant chat message processing.\n- Secure handling of chatbot credentials.\n- User-friendly command management interface."
```

### **Issue 14.2: Feature: Advanced Stream Event Orchestration (Workflows)**

```bash
gh issue create --title "Feature: Implement Advanced Stream Event Orchestration (Workflows)" --body "## Description\nMove beyond simple event-to-action mapping to a powerful workflow engine, allowing streamers to define complex sequences of actions triggered by stream events or conditions.\n\n## Acceptance Criteria:\n- Users can create visual workflows (e.g., using a node-based editor) to define multi-step actions.\n- Workflows can be triggered by any stream event (e.g., follower alert, donation, channel points, chat command).\n- Actions include: scene changes, overlay visibility toggles, sound effects, API calls, chatbot messages, conditional logic.\n- Workflows are persistent (Issue 1.1).\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Implement a workflow engine (e.g., using a BPMN-like library or custom state machine).\n  - Integrate with `StreamEventsGateway` for triggers and expose actions via API.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for visual workflow creation and management.\n  - Integration with existing scene/overlay/audio services.\n\n## Best Practices:\n- Intuitive visual workflow editor.\n- Robust error handling and debugging for workflows.\n- Comprehensive action library."
```

### **Issue 14.3: Feature: Stream Health Prediction & AI-Driven Optimization**

```bash
gh issue create --title "Feature: Implement Stream Health Prediction & AI-Driven Optimization" --body "## Description\nElevate stream monitoring (Issue 3.5) with AI-powered prediction of potential issues (e.g., impending bitrate drop due to network congestion) and automatic optimization suggestions or actions.\n\n## Acceptance Criteria:\n- AI analyzes real-time stream metrics and network conditions to predict potential stream health degradation.\n- Stream Buddy alerts the streamer to predicted issues.\n- AI suggests optimal encoding settings or network adjustments.\n- (Future) Stream Buddy can automatically apply minor optimizations (e.g., slightly reduce bitrate) to mitigate predicted problems.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Develop AI/ML models for time-series analysis and prediction of stream health metrics.\n  - Integrate with ISP/network performance APIs (where available).\n- **Frontend (`libs/core/services/`, `apps/stream-buddy/`):**\n  - `StreamMonitoringService` feeds data to AI model.\n  - UI for AI predictions and suggestions.\n  - Controls for auto-optimization.\n\n## Best Practices:\n- High accuracy for predictions.\n- Non-intrusive and transparent auto-optimization.\n- User-configurable thresholds and preferences for AI actions."
```

### **Issue 14.4: Feature: Custom Streamer Dashboard & Analytics Reporting API**

```bash
gh issue create --title "Feature: Implement Custom Streamer Dashboard & Analytics Reporting API" --body "## Description\nProvide a highly customizable streamer dashboard where users can arrange widgets displaying key stream information and create custom analytics reports, and expose an API for external dashboard tools.\n\n## Acceptance Criteria:\n- Users can drag, resize, and configure dashboard widgets (e.g., chat, stats, scene preview, event log).\n- Users can create and save multiple custom dashboard layouts.\n- Stream Buddy exposes a secure API (e.g., GraphQL or REST) for external tools to pull real-time and historical stream data for custom reporting.\n- UI for managing API keys and dashboard layouts.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Develop a robust API for real-time and historical stream data access.\n  - Implement API key management and security.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for dashboard widget management.\n  - Integration of charting/data visualization libraries.\n\n## Best Practices:\n- Secure and well-documented API.\n- Efficient data retrieval for real-time dashboards.\n- Flexible widget architecture."
```

### **Issue 14.5: Feature: Advanced Game Integration (Game Hooks, Data Overlay)**

```bash
gh issue create --title "Feature: Implement Advanced Game Integration (Game Hooks, Data Overlay)" --body "## Description\nDevelop deeper integration with popular games to extract in-game data (e.g., player stats, scores, in-game events) and display it as dynamic, real-time overlays, enhancing gameplay commentary and viewer engagement.\n\n## Acceptance Criteria:\n- Stream Buddy can connect to specific games (e.g., via APIs, memory hooks, or custom game integrations).\n- In-game data is extracted and available as `StreamEvent`s.\n- Users can configure overlays (Issue 2.4.2) to display real-time in-game stats (e.g., KDA, health bar, objective status).\n- (Future) Trigger Stream Buddy actions based on in-game events.\n\n## Technical Details\n- **Desktop Application (Issue 6.2):**\n  - Implement game-specific hooks/APIs (highly OS and game dependent).\n  - **WASM/Native:** Develop native components (or WASM-compiled modules) to interface with game processes or APIs.\n- **Backend (`apps/api`):**\n  - API endpoints to receive and process in-game data.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for configuring game integrations and data mapping.\n  - `OverlayRendererService` and `SceneCompositorService` display in-game data.\n\n## Best Practices:\n- Respect game terms of service for integration.\n- Efficient and low-overhead data extraction.\n- Robust error handling for game updates."
```

---

## Major Version 15: Future-Proofing & Ecosystem Growth

### **Issue 15.1: Feature: Plugin / Extension Marketplace**

```bash
gh issue create --title "Feature: Implement a Plugin / Extension Marketplace" --body "## Description\nEstablish an extensible architecture and a marketplace for community-contributed plugins and extensions, allowing users to expand Stream Buddy's functionality beyond core features (e.g., custom overlays, niche integrations, specialized tools).\n\n## Acceptance Criteria:\n- Stream Buddy provides a documented Plugin API/SDK.\n- Users can discover, install, and manage plugins from within the application.\n- Plugins can extend various parts of Stream Buddy (e.g., new overlay types, custom stream events, unique integrations).\n- A secure sandbox environment for script execution to prevent malicious code.\n\n## Technical Details:\n- **Backend (`apps/api`):**\n  - Implement API for plugin discovery and metadata management.\n  - Security review process for submitted plugins.\n- **Frontend (`apps/stream-buddy`):**\n  - **Plugin Runtime (WASM/JS):** Develop a secure plugin runtime environment (e.g., Web Workers, WASM modules, or Electron's `ContextBridge` for native access).\n  - UI for plugin browsing, installation, and management.\n\n## Best Practices:\n- Strong security model for plugin execution.\n- Comprehensive Plugin API documentation.\n- Community guidelines for plugin development and submission."
```

### **Issue 15.2: Feature: AI-Driven Content Repurposing & Multi-Format Export**

```bash
gh issue create --title "Feature: Implement AI-Driven Content Repurposing & Multi-Format Export" --body "## Description\nFurther automate content creation by using AI to repurpose live stream segments into various formats (e.g., blog posts, audio podcasts, highlight reels with different aspect ratios) for wider distribution.\n\n## Acceptance Criteria:\n- AI analyzes VODs (Issue 9.5) and generated clips (Issue 7.2).\n- AI can generate text summaries (for blog posts) from transcriptions (Issue 7.5).\n- AI can suggest audio-only segments for podcast export.\n- Users can export content in various formats (e.g., MP3 for audio, different video aspect ratios/resolutions).\n- UI for managing repurposing tasks and formats.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - **AI Models:** Integrate AI models for summarization, content extraction, and format recommendation.\n  - **Media Processing:** `ffmpeg` (WASM/server-side) for audio extraction, video reformatting.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for content repurposing workflow.\n  - Preview of generated content.\n\n## Best Practices:\n- High quality and coherence for AI-generated content.\n- Flexible export options.\n- Clear consent for content repurposing."
```

### **Issue 15.3: Feature: Stream Buddy Cloud Sync & Backup**

```bash
gh issue create --title "Feature: Implement Stream Buddy Cloud Sync and Backup" --body "## Description\nProvide a cloud synchronization and backup solution for all user configurations, scenes, overlays, and assets, enabling users to seamlessly switch devices, restore settings, and protect their work.\n\n## Acceptance Criteria:\n- Users can link a cloud storage provider (e.g., Google Drive, Dropbox, Stream Buddy's own cloud).\n- All user data (Issue 1.1) is automatically synchronized and backed up to the cloud.\n- Users can restore configurations from cloud backups.\n- Manual backup/restore options.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Implement integration with various cloud storage APIs.\n  - Develop secure synchronization and backup logic.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for managing cloud sync settings.\n  - Progress indicators for sync/backup operations.\n\n## Best Practices:\n- Secure encryption of data in transit and at rest in the cloud.\n- Robust conflict resolution for synchronized data.\n- Clear user control over privacy and data retention."
```

### **Issue 15.4: Feature: Advanced Teleprompter / Notes Overlay**

```bash
gh issue create --title "Feature: Implement Advanced Teleprompter / Notes Overlay" --body "## Description\nProvide a sophisticated teleprompter or notes display integrated into the Stream Buddy environment, allowing streamers to follow scripts, key points, or interact with a dynamic display without breaking eye contact with the camera.\n\n## Acceptance Criteria:\n- Users can create/import scripts or notes.\n- Text is displayed as a customizable overlay (Issue 2.4.2), scrollable at a configurable speed.\n- Streamer can control scrolling (e.g., via hotkey, foot pedal, or eye-tracking if available).\n- (Future) Integration with external text editors or cloud documents.\n\n## Technical Details\n- **Frontend (`apps/stream-buddy`, `libs/core/services/`):**\n  - UI for script/notes creation and editing.\n  - `OverlayRendererService` and `SceneCompositorService` draw the dynamic teleprompter text.\n  - Implement text scrolling logic and control mechanisms.\n\n## Best Practices:\n- Smooth, readable text scrolling.\n- Intuitive controls for speed and position.\n- Non-distracting display for the streamer."
```

### **Issue 15.5: Enhancement: Full API for Remote Control & Automation**

```bash
gh issue create --title "Enhancement: Provide a Full, Secure API for Remote Control and Automation" --body "## Description\nExpose a comprehensive, well-documented, and secure API for Stream Buddy, allowing third-party tools, custom scripts, or home automation systems to remotely control virtually all aspects of the application.\n\n## Acceptance Criteria:\n- Stream Buddy exposes a secure RESTful API and/or WebSocket API.\n- API allows control over scenes, sources, overlays, stream state (start/stop), metadata, and trigger events.\n- Comprehensive API documentation (e.g., OpenAPI/Swagger).\n- Robust API key management and authentication.\n\n## Technical Details\n- **Backend (`apps/api`):**\n  - Design and implement API endpoints for all controllable features.\n  - Implement API key generation, validation, and revocation.\n  - Ensure secure access and rate limiting.\n- **Frontend (`apps/stream-buddy`):**\n  - UI for API key management and documentation access.\n\n## Best Practices:\n- Secure API design (OAuth, API keys).\n- Clear and consistent API contracts.\n- Performance optimization for API endpoints."
```
